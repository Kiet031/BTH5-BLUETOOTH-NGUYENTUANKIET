<!-- Copilot / AI agent instructions for the dht11-web project -->
# Project overview

- **Purpose:** Small Express.js web scaffold serving static assets and EJS views. There is no sensor or hardware code present in this repository; the app only renders views and serves static files.
- **Entrypoint:** `bin/www` creates the HTTP server which requires `app.js`.
- **View engine:** EJS templates live in `views/` (examples: `views/index.ejs`, `views/error.ejs`).
- **Static assets:** Served from `public/` (stylesheets at `public/stylesheets/style.css`).

# Architecture & data flow (short)

- HTTP request -> Express middleware (`app.js`) -> route handlers in `routes/` -> render EJS or serve static files from `public/`.
- Route examples: `routes/index.js` renders `index.ejs` for `GET /`. `routes/users.js` is present but not used in other parts of the app beyond being mounted at `/users` in `app.js`.

# Developer workflows

- Start the app (development):

  - For PowerShell: `$env:PORT=3000; npm start`
  - Or: `npm start` (defaults to port 3000). `start` runs `node ./bin/www` as defined in `package.json`.

- Change the listening port using `PORT` environment variable. On Windows PowerShell set it with `$env:PORT=4000; npm start`.

- Debug logging: set the `DEBUG` env var. Example (PowerShell): `$env:DEBUG='dht11-web:*'; $env:PORT=3000; npm start` â€” the server uses the `debug` package and prints `dht11-web:server` messages.

# Project-specific conventions & patterns

- This repo is an Express-generator style scaffold:
  - Application config in `app.js` (middleware, views, static).
  - `bin/www` is the process entry that creates the HTTP server and normalizes the port.
  - Routes live under `routes/` and export an Express `Router`.
  - EJS templates expect view locals passed by route handlers (e.g., `res.render('index', { title: 'Express' })`).

- Keep static assets under `public/` and reference them by absolute paths in templates (e.g., `<link href="/stylesheets/style.css">`).

- No database, message queues, or hardware integrations are present in the codebase; avoid adding assumptions about sensor code unless a new module clearly implements it.

# Integration points & dependencies

- Key dependencies (see `package.json`): `express`, `ejs`, `morgan`, `cookie-parser`, `debug`, `http-errors`.
- External integration hooks to look for when extending the repo:
  - Add API endpoints in `routes/` and mount them in `app.js`.
  - If adding hardware/sensor code, keep it separate from web routing (create `lib/` or `services/` and inject results into routes to keep concerns separated).

# Guidance for AI agents (concrete, actionable)

- When making changes, preserve the Express-generator layout: update `app.js` for middleware, `routes/` for endpoints, `views/` for templates, `public/` for static assets, and `bin/www` only for process-level concerns.

- Use `npm start` to run the app locally. For debugging, set `DEBUG='dht11-web:*'` and `PORT` as needed.

- Examples to reference in edits:
  - Add a JSON API route: create `routes/api.js`, export Router, mount with `app.use('/api', require('./routes/api'))` in `app.js`.
  - Render data in an EJS view: `res.render('index', { title: 'Dashboard', data: myData })` and reference `data` in `views/index.ejs`.

- Avoid modifying the generated `bin/www` unless you need to change process- or port-level behavior (e.g., cluster setup, signal handling).

# What I could not discover

- There is no README describing developer workflows or intended features (other than code layout). There is no test suite or CI configuration in the repo to reference.

# If you want me to expand

- Tell me whether the DHT11 sensor logic lives in another repo or should be added here. I can then:
  - Add a `services/dht11.js` adapter and show how to inject readings into routes, or
  - Wire a simple API endpoint that returns mocked sensor data for frontend development.

---
_Generated by AI agent: use this file to guide focused, repository-aware suggestions and code edits._
